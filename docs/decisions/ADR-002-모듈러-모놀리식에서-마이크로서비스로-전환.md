# ADR-002: 모듈러 모놀리식에서 마이크로서비스로의 점진적 전환

> Gateway(WebFlux)와 서비스(MVC)의 기술 스택 혼재가 불가능하여 배포 단위 분리. modules는 공유하되 services는 독립 실행

## 상태
채택됨 (Accepted)

## 배경

### 목표
- Gateway와 서비스의 기술 스택 충돌 회피
- 서비스 분리와 독립 실행 가능성 확보

## 아키텍처 진화 과정

### 1단계: 모듈러 모놀리식 (초기 계획)

**구조**
```
nextmall/
├── common/          # 공통 모듈
├── modules/
│   ├── user/        # 유저 모듈
│   ├── auth/        # 인증 모듈
│   └── bff/         # bff 모듈
└── application/     # 단일 실행 진입점
```

**특징**
- 모든 모듈을 하나의 JAR로 패키징
- 단일 프로세스로 실행
- 모듈 간 직접 호출 가능

**단점**
- MSA 특성 체감이 제한적
- 서비스 간 격리 한계
- 독립 배포 불가
- 기술 스택 혼재 불가 (WebFlux + MVC)

### 2단계: 전환점 - Gateway 도입 결정

**이슈**
- API Gateway를 WebFlux로 구현하고 싶음 (비동기, 높은 처리량)
- 하지만 뒷단 서비스는 모두 Spring MVC
- **단일 JAR에서 WebFlux + MVC 혼재 불가**

**선택지**
1. 모두 MVC로 통일
2. 모두 WebFlux로 통일
3. **배포 단위만 분리** → Gateway는 WebFlux, 나머지는 MVC

### 3단계: 배포 단위 분리 (현재 기준 정리)

**구조**
```
nextmall/
├── common/                    # 공통 라이브러리
│   ├── common-core/
│   ├── common-security/
│   └── common-kafka/
├── modules/                   # 비즈니스 모듈 (재사용)
│   ├── user/
│   ├── auth/
│   └── bff/
└── services/                  # 배포 단위
    ├── api-gateway/           # WebFlux
    ├── bff-service/           # WebFlux
    ├── orchestrator-service/  # WebFlux
    ├── user-service/          # MVC
    └── auth-service/          # MVC
```

**핵심 아이디어**
- **modules**: 비즈니스 로직을 담은 재사용 가능한 모듈
- **services**: 배포 단위, modules를 조합하여 실행 가능한 애플리케이션 생성
- Gateway와 BFF는 WebFlux 기반으로 정리
- 나머지 서비스는 MVC 기반으로 유지

## 대안 비교

| 구분 | 모듈러 모놀리식 | 완전한 MSA | 하이브리드 (선택) |
|------|----------------|-----------|------------------|
| **개발 속도** | 빠름 | 느림 | 중간 |
| **MSA 학습** | 불가 | 가능 | 가능 |
| **인프라 복잡도** | 낮음 | 높음 | 중간 |
| **기술 스택 유연성** | 낮음 | 높음 | 높음 |
| **디버깅** | 쉬움 | 어려움 | 중간 |
| **독립 배포** | 불가 | 가능 | 가능 |

## 결정

**배포 단위만 분리하는 하이브리드 구조**를 채택한다.

### 핵심 선택 이유

**1. 기술 스택 유연성**
- Gateway는 WebFlux로 비동기 처리
- 나머지 서비스는 MVC로 빠른 개발
- 각 서비스가 독립적인 기술 선택 가능

**2. 점진적 전환 가능**
- 초기: 모듈로 개발 (빠른 개발)
- 필요시: 서비스로 분리 (독립 배포)
- 학습 곡선 완화

**3. 코드 재사용**
- modules를 여러 services에서 재사용
- 공통 로직 중복 제거
- 일관된 비즈니스 로직

**4. 현실적 제약 대응**
- 1인 개발에 적합한 복잡도
- 로컬 환경에서 실행 가능
- 빠른 실험과 학습

**5. 학습 목표**
- MSA 핵심 패턴 학습
- 서비스 간 통신 (REST, Kafka)
- 분산 트랜잭션 (사가 패턴)
- API Gateway 패턴

## 구현 예시

상세 구현은 각 서비스의 설정/코드에 반영되어 있다.

## 트레이드오프

### 얻는 것
- 기술 스택 혼재 방지
- 독립 배포 가능성 확보
- 점진적 전환 여지

### 포기하는 것
- 완전한 서비스 독립성 (modules 공유)

