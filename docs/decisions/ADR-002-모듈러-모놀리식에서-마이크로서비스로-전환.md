# ADR-002: 모듈러 모놀리식에서 마이크로서비스로의 점진적 전환

> Gateway(WebFlux)와 서비스(MVC)의 기술 스택 혼재가 불가능하여 배포 단위 분리. modules는 공유하되 services는 독립 실행

## 상태
채택됨 (Accepted)

## 배경

### 실무 MSA의 한계

현재 실무에서 마이크로서비스 아키텍처를 운영 중이지만, 다음과 같은 한계가 있다:

- **서비스 분리만 존재**: 각 서비스는 분리되어 있지만 WebClient로 동기 호출만 수행
- **MSA 핵심 패턴 부재**
  - Circuit Breaker 없음
  - 메시지 큐 없음 (이벤트 드리븐 아키텍처 부재)
  - 캐싱 전략 없음 (Redis 미사용)
  - 분산 트랜잭션 처리 없음 (사가 패턴 부재)
- **모니터링 제한**: Datadog만 사용, 분산 추적 미구축
- **리소스 제약**: 시스템당 2명, 하지만 시스템 규모는 큼

이는 "서비스만 분리된 MSA"로, MSA의 핵심 패턴과 장점을 충분히 활용하지 못하고 있다.

### 토이 프로젝트의 학습 목표

실무에서 경험하지 못한 MSA 핵심 패턴들을 학습하고 실험하기 위해 토이 프로젝트를 시작했다:

- Circuit Breaker, Retry, Timeout 등 회복성 패턴
- 사가 패턴을 통한 분산 트랜잭션 처리
- 이벤트 드리븐 아키텍처 (Kafka)
- 캐싱 전략 (로컬 캐시 + Redis)
- API Gateway 패턴
- CQRS 패턴

### 현실적 제약

- **1인 개발**: 퇴근 후 + 주말에만 개발 가능
- **시간 제약**: 빠른 개발과 실험이 필요
- **인프라 제약**: 로컬 환경에서 여러 서비스 동시 실행
- **학습 우선**: 완벽한 MSA보다 핵심 패턴 학습이 목표

## 아키텍처 진화 과정

### 1단계: 모듈러 모놀리식 (초기 계획)

**구조**
```
nextmall/
├── common/          # 공통 모듈
├── modules/
│   ├── user/        # 유저 모듈
│   ├── auth/        # 인증 모듈
│   └── bff/         # bff 모듈
└── application/     # 단일 실행 진입점
```

**특징**
- 모든 모듈을 하나의 JAR로 패키징
- 단일 프로세스로 실행
- 모듈 간 직접 호출 가능

**장점**
- 빠른 개발 가능
- 로컬에서 단일 프로세스로 실행
- 모듈 간 의존성 관리 용이
- 디버깅 쉬움

**단점**
- 진짜 MSA 경험 불가
- 서비스 간 격리 부족
- 독립 배포 불가
- 기술 스택 혼재 불가 (WebFlux + MVC)

### 2단계: 전환점 - Gateway 도입 결정

**문제 발생**
- API Gateway를 WebFlux로 구현하고 싶음 (비동기, 높은 처리량)
- 하지만 뒷단 서비스는 모두 Spring MVC
- **단일 JAR에서 WebFlux + MVC 혼재 불가**

**선택지**
1. 모두 MVC로 통일 → Gateway 성능 포기
2. 모두 WebFlux로 통일 → 학습 곡선 가파름, 개발 속도 저하
3. **배포 단위만 분리** → Gateway는 WebFlux, 나머지는 MVC

### 3단계: 최종 구조 - 배포 단위 분리

**구조**
```
nextmall/
├── common/                    # 공통 라이브러리
│   ├── common-core/
│   ├── common-security/
│   └── common-kafka/
├── modules/                   # 비즈니스 모듈 (재사용)
│   ├── user/
│   ├── auth/
│   └── bff/
└── services/                  # 배포 단위
    ├── api-gateway/           # WebFlux
    ├── bff-service/           # MVC
    ├── user-service/          # MVC    
    └── auth-service/          # MVC
```

**핵심 아이디어**
- **modules**: 비즈니스 로직을 담은 재사용 가능한 모듈
- **services**: 배포 단위, modules를 조합하여 실행 가능한 애플리케이션 생성
- Gateway만 WebFlux, 나머지는 MVC

## 대안 비교

| 구분 | 모듈러 모놀리식 | 완전한 MSA | 하이브리드 (선택) |
|------|----------------|-----------|------------------|
| **개발 속도** | 빠름 | 느림 | 중간 |
| **MSA 학습** | 불가 | 가능 | 가능 |
| **인프라 복잡도** | 낮음 | 높음 | 중간 |
| **기술 스택 유연성** | 낮음 | 높음 | 높음 |
| **디버깅** | 쉬움 | 어려움 | 중간 |
| **독립 배포** | 불가 | 가능 | 가능 |

## 결정

**배포 단위만 분리하는 하이브리드 구조**를 채택한다.

### 핵심 선택 이유

**1. 기술 스택 유연성**
- Gateway는 WebFlux로 비동기 처리
- 나머지 서비스는 MVC로 빠른 개발
- 각 서비스가 독립적인 기술 선택 가능

**2. 점진적 전환 가능**
- 초기: 모듈로 개발 (빠른 개발)
- 필요시: 서비스로 분리 (독립 배포)
- 학습 곡선 완화

**3. 코드 재사용**
- modules를 여러 services에서 재사용
- 공통 로직 중복 제거
- 일관된 비즈니스 로직

**4. 현실적 제약 해결**
- 1인 개발에 적합한 복잡도
- 로컬 환경에서 실행 가능
- 빠른 실험과 학습

**5. 실무 학습 목표 달성**
- MSA 핵심 패턴 학습 가능
- 서비스 간 통신 (REST, Kafka)
- 분산 트랜잭션 (사가 패턴)
- API Gateway 패턴

## 구현 예시

### Module 정의
```kotlin
// modules/user/src/main/kotlin
@Component
class UserService(
    private val userRepository: UserRepository
) {
    fun createUser(command: CreateUserCommand): User {
        // 비즈니스 로직
    }
}
```

### Service에서 Module 사용
```kotlin
// services/user-service/build.gradle.kts
dependencies {
    implementation(project(":modules:user"))
    implementation(project(":common:data"))
    ...
}

// services/user-service/src/main/kotlin
@SpringBootApplication(
  scanBasePackages = [
    "com.nextmall.userservice",
    "com.nextmall.user",
    "com.nextmall.common",
  ],
)
@ConfigurationPropertiesScan(
  "com.nextmall.userservice",
  "com.nextmall.user",
  "com.nextmall.common",
)
class UserServiceApplication

fun main(args: Array<String>) {
  runApplication<UserServiceApplication>(*args)
}

```

### Gateway (WebFlux)
```kotlin
// services/api-gateway/src/main/kotlin
@Configuration
class RouteConfig {
    @Bean
    fun routes(builder: RouteLocatorBuilder): RouteLocator =
        builder
            .routes()
            .route("bff-v1-route") {
                it
                    .path("/api/v1/**")
                    .filters { f -> f.stripPrefix(2) }
                    .uri(props.bff.baseUrl)
            }.build()
}
```

## 트레이드오프

### 얻는 것
- 기술 스택 유연성 (WebFlux + MVC 공존)
- MSA 핵심 패턴 학습 가능
- 독립 배포 가능
- 코드 재사용 (modules)
- 점진적 전환 가능

### 포기하는 것
- 완전한 서비스 독립성 (modules 공유)
- 일부 중복 코드 발생 가능
- 모듈 간 의존성 관리 필요

### 향후 고려사항
- 서비스가 안정화되면 modules를 각 서비스에 내재화 검토
- 공통 로직은 라이브러리로 분리
- 서비스 간 의존성 최소화

## 실무 적용 가능성

이 구조는 다음과 같은 실무 상황에 적합하다:

1. **레거시 모놀리식 → MSA 전환**: 점진적 분리 전략
2. **소규모 팀**: 적은 인원으로 MSA 운영
3. **빠른 개발 필요**: 초기 개발 속도 유지하면서 MSA 이점 확보
4. **기술 스택 전환**: 일부 서비스만 새 기술 도입

토이 프로젝트에서 검증 후, 실무에 적용 가능한 패턴으로 발전시킬 수 있다.
