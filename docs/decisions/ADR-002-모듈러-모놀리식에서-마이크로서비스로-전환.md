# ADR-002: 모듈러 모놀리식에서 마이크로서비스로의 점진적 전환

> Gateway(WebFlux)와 서비스(MVC)의 기술 스택 혼재가 불가능하여 배포 단위 분리. modules는 공유하되 services는 독립 실행

## 상태
수정됨 (Revised)

## 배경

### 목표
- Gateway와 서비스의 기술 스택 충돌 회피
- 서비스 분리와 독립 실행 가능성 확보

## 아키텍처 진화 과정

### 1단계: 모듈러 모놀리식 (초기 계획)

#### 구조
```
nextmall/
├── common/          # 공통 모듈
├── modules/
│   ├── user/        # 유저 모듈
│   ├── auth/        # 인증 모듈
│   └── bff/         # bff 모듈
└── application/     # 단일 실행 진입점
```

#### 특징
- 모든 모듈을 하나의 JAR로 패키징
- 단일 프로세스로 실행
- 모듈 간 직접 호출 가능

#### 단점
- MSA 특성 체감이 제한적
- 서비스 간 격리 한계
- 독립 배포 불가
- 기술 스택 혼재 불가 (WebFlux + MVC)

### 2단계: 전환점 - Gateway 도입 결정

#### 이슈
- API Gateway를 WebFlux로 구현하고 싶음 (비동기, 높은 처리량)
- 하지만 뒷단 서비스는 모두 Spring MVC
- 단일 JAR에서 WebFlux + MVC 혼재 불가

#### 선택지
1. 모두 MVC로 통일
2. 모두 WebFlux로 통일
3. 배포 단위만 분리 → Gateway는 WebFlux, 나머지는 MVC

### 3단계: 배포 단위 분리 (현재 기준 정리)

#### 구조 (현재)
```
nextmall/
├── common/                    # 공통 라이브러리
│   ├── authorization/
│   ├── data/
│   ├── exception/
│   ├── identifier/
│   ├── kafka/
│   ├── security/
│   ├── security-core/
│   └── util/
└── services/                  # 배포 단위
    ├── api-gateway/           # WebFlux
    ├── bff-service/           # WebFlux
    ├── orchestrator-service/  # WebFlux
    ├── user-service/          # MVC
    ├── auth-service/          # MVC
    ├── product-service/       # MVC
    └── order-service/         # MVC
```

#### 핵심 아이디어 (수정)
- modules 계획은 services로 통합하여 단순화
- 재사용은 common 모듈 중심으로 유지
- services는 독립 실행/배포 단위로 유지
- Gateway/BFF/Orchestrator는 WebFlux 기반, 나머지 서비스는 MVC 기반 유지

## 대안 비교

| 구분 | 모듈러 모놀리식 | 완전한 MSA | 하이브리드 (선택) |
|------|----------------|-----------|------------------|
| **개발 속도** | 빠름 | 느림 | 중간 |
| **MSA 학습** | 불가 | 가능 | 가능 |
| **인프라 복잡도** | 낮음 | 높음 | 중간 |
| **기술 스택 유연성** | 낮음 | 높음 | 높음 |
| **디버깅** | 쉬움 | 어려움 | 중간 |
| **독립 배포** | 불가 | 가능 | 가능 |

## 결정

### 배포 단위만 분리하는 하이브리드 구조 채택

### 핵심 선택 이유

#### 1. 기술 스택 유연성
- Gateway는 WebFlux로 비동기 처리
- 나머지 서비스는 MVC로 빠른 개발
- 각 서비스가 독립적인 기술 선택 가능

#### 2. 점진적 전환 가능
- 초기: 모듈로 개발 (빠른 개발)
- 필요시: 서비스로 분리 (독립 배포)
- 학습 곡선 완화

#### 3. 코드 재사용
- common 모듈을 여러 서비스에서 재사용
- 공통 로직 중복 제거

#### 4. 현실적 제약 대응
- 1인 개발에 적합한 복잡도
- 로컬 환경에서 실행 가능
- 빠른 실험과 학습

#### 5. 학습 목표
- MSA 핵심 패턴 학습
- 서비스 간 통신 (REST, Kafka)
- 분산 트랜잭션 (사가 패턴)
- API Gateway 패턴

## 구현 예시

상세 구현은 각 서비스의 설정/코드에 반영되어 있다.

## 트레이드오프

### 얻는 것
- 기술 스택 혼재 방지
- 독립 배포 가능성 확보
- 점진적 전환 여지

### 포기하는 것
- 완전한 서비스 독립성 (modules 공유)

## 변경 이력
- 2026-01-24: modules 계획을 services로 통합하고 common 중심 구조로 정리

