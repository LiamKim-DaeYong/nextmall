# ADR-006: 모듈 간 의존성 원칙 및 test-support 역할 정의

> 순환 의존성 완화와 모듈 계층 정리. test-support는 테스트 인프라 제공자, common은 순수 비즈니스 로직

## 상태
채택됨 (Accepted)

## 배경

프로젝트 초기에는 모듈 간 의존성 방향에 대한 일관된 원칙이 없었고, 편의성을 위해 의존성을 추가하다 보니 순환 의존성 문제가 발생했다.

### 발견된 순환 의존성

**1. kafka ↔ test-support**
```
test-support → kafka (implementation)
kafka → test-support (testImplementation)
```

**2. security ↔ test-support**
```
test-support → security (implementation)
security → test-support (testImplementation)
```

### 근본 원인

**test-support의 역할 혼란**
- 테스트 인프라 제공자인지, common 모듈의 소비자인지 불명확
- 편의성을 위해 common 모듈을 의존하면서 동시에 common 모듈도 test-support를 의존

**common 모듈의 테스트 전략 부재**
- common 모듈들이 통합 테스트 환경(Testcontainers 등)을 필요로 한다고 가정
- 실제로는 순수 단위 테스트만으로 충분한 경우가 대부분

**편의성 우선**
- 순환 의존성보다 코드 재사용을 우선시
- 장기적 유지보수성보다 단기적 개발 속도 우선

## 대안 비교

### 1. 현상 유지 (순환 의존성 허용)
- 장점: 코드 재사용 용이, 개발 속도 빠름
- 단점: 빌드 불안정, 모듈 경계 모호, 장기적 유지보수 어려움
- **선택하지 않은 이유**: 기술 부채 누적, 프로젝트 확장 시 문제 심화

### 2. test-support를 각 모듈에 복제
- 장점: 순환 의존성 완전 제거
- 단점: 코드 중복 심각, 테스트 인프라 일관성 저하
- **선택하지 않은 이유**: 유지보수 비용 과다

### 3. 일관된 계층 구조 정의 (선택)
- 장점: 의존성 방향이 비교적 분명해짐, 순환 의존성 완화, 확장성 측면에서 유리
- 단점: 초기 리팩토링 비용, 일부 코드 중복 발생
- **선택 이유**: 장기적 유지보수성과 확장성 확보

## 결정

### 1. 모듈 계층 구조 정의

```
common/* (프로덕션 코드, 순수 비즈니스 로직)
  ↑
test-support (테스트 인프라 제공)
  ↑
modules/*, services/* (실제 비즈니스 로직 + 통합 테스트)
```

**핵심 원칙:**
- 의존성은 위에서 아래로만 흐름
- 하위 계층은 상위 계층을 의존하지 않음
- 순환 의존성 원천 차단

### 2. test-support의 역할

**책임:**
- 테스트 어노테이션 제공 (@IntegrationTest, @RepositoryTest 등)
- Testcontainers 설정 제공
- 테스트용 유틸리티 제공 (TestJwtFactory, NoOpEventPublisher 등)
- 테스트 프레임워크 의존성 통합 관리

**원칙:**
- common 모듈을 의존할 수 있음 (테스트 인프라 구축 목적)
- common 모듈은 test-support를 의존하지 않음 (순환 방지)
- modules/services는 test-support를 통해 통합 테스트 수행

### 3. common 모듈의 테스트 전략

**원칙:**
- common 모듈은 **순수 단위 테스트**만 수행
- 통합 테스트는 불필요 (실제 사용처인 modules/services에서 수행)
- testImplementation은 최소한으로 (kotest, mockk 정도)

**적용 결과:**

| 모듈 | testImplementation |
|------|-------------------|
| authorization | kotest |
| data | kotest |
| integration | kotest, mockk |
| kafka | - |
| security | kotest, mockk |

### 4. 순환 의존성 대응 방법

**kafka ↔ test-support**
- `kafka`에서 `test-support` 제거
- kafka 모듈은 단위 테스트만 수행하거나 테스트 없이 운영
- 통합 테스트는 kafka를 사용하는 상위 모듈에서 수행

**security ↔ test-support**
- `test-support`에서 `security` 제거
- `security` 테스트는 로컬 헬퍼 함수 사용 (간단한 Jwt 생성)
- TestJwtFactory는 test-support에 유지 (다른 모듈에서 사용)

## 트레이드오프

### 얻는 것
- 일관된 의존성 방향으로 새로운 모듈 추가 시 혼란 감소
- 순환 의존성 완화로 빌드 안정성 향상
- common 모듈 순수성 확보로 프로덕션 코드와 테스트 코드의 경계 정리
- 테스트 전략 정리 (단위 테스트 vs 통합 테스트)

### 포기하는 것
- 테스트 코드 일부 중복 (security 모듈의 Jwt 생성 헬퍼)
- common 모듈에서 Testcontainers 직접 사용 불가

### 리스크 완화
- 중복 코드는 간단한 헬퍼 함수 수준으로 수용 가능
- 실제 통합 테스트는 상위 계층(modules/services)에서 수행하는 쪽으로 정리

## 의존성 매트릭스

| 모듈 | 의존 대상 | testImplementation |
|------|-----------|-------------------|
| common/exception | - | - |
| common/util | - | kotest, mockk |
| common/identifier | - | kotest, mockk |
| common/policy | - | kotest |
| common/security | exception | kotest, mockk |
| common/redis | - | kotest, mockk |
| common/kafka | - | - |
| common/data | util | kotest |
| common/integration | exception, util | kotest, mockk |
| common/authorization | policy, exception, security | kotest |
| **test-support** | identifier, kafka, redis | (api로 테스트 프레임워크 제공) |

## 향후 고려사항

**공통 테스트 유틸 증가 시**
- test-support 내부 모듈화 검토
- 도메인별 테스트 유틸 분리 (예: test-support-auth, test-support-user)

**common 모듈 통합 테스트 필요 시**
- 별도 test 모듈 분리 고려 (예: common-integration-test)
- 하지만 대부분의 경우 상위 계층 테스트로 충분

**의존성 검증 자동화**
- Gradle 플러그인으로 순환 의존성 감지
- CI/CD 파이프라인에 의존성 검증 단계 추가
