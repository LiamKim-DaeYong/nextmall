# ADR-004: PBAC 기반 인가 방식 선택

> 실무에서 겪은 "정책-코드 강결합" 문제 해결. 정책을 데이터로 분리하여 코드 변경 없이 런타임 정책 변경 가능

## 상태
채택됨 (Accepted)

## 배경

현재 물류 도메인 실무에서 **정책 관리**의 어려움을 겪고 있다:

### 물류 도메인의 정책 문제
- 미국 정수기 렌탈 사업의 복잡한 검증 정책
  - 설치기사(창고로 관리) 할당 가능 여부 검증 → 분기 로직 과다
  - 차용재고 정책: 부품/소모품은 사전 신청 후 차량 보관 가능, 제품/필터는 당일 배정-설치-반납 필수
  - 시리얼번호 기반 재고 추적 및 상태 관리
  - 입출고 유형별 상이한 처리 로직 (설치 출고, 회수 입고, 교체, 이동 등)
- 초기: if문과 if-else 도배 → 복잡도 증가, 버그 다발
- 개선: 파이프라인 기반 라이프사이클 + 전략 패턴으로 검증 로직 구현
- **여전히 문제**: 정책이 코드에 녹아있어 정책 변경 시 코드 수정 불가피

### 핵심 인사이트
**물류든 인가든, 결국 "정책"을 다루는 것**
- 물류: 검증 정책 
  - 설치기사 창고 + INSTALLED 출고 → 즉시 완료 처리
  - 일반 창고 → SCHEDULED 상태
  - 주문이 취소 되었을 때 
    - 설치기사 수령 전 -> 재고이동 지시서 생성 (Rollback)
    - 설치기사 수령 후 -> 반환 예정서(창고 입고 예정서 / 설치기사 출고 예정서) 생성
- 인가: 접근 정책
  - "본인 주문만 조회 가능"
  - "100만원 이상 주문은 관리자만 환불 처리 가능"
  - "부서장은 팀원 주문 조회 가능"
- 공통점: 정책은 언제든 변할 수 있는데, 코드에 강결합되면 유연성 상실

### 문제 정의
- 정책 변경 → 코드 변경 → 배포 → 버그 발생의 악순환
- SRP 위반: 코드의 변경 사유가 "정책1 변경", "정책2 변경", "비즈니스 로직 변경" 등 너무 많음
- ABAC도 결국 속성 기반 로직이 코드에 구현되어 동일한 문제 발생

**정책과 코드를 분리**하여 유연하게 대응할 수 있는 구조가 필요하다.

## 인가 방식 비교

| 구분 | RBAC | ABAC | PBAC |
|------|------|------|------|
| **제어 단위** | 역할(Role) | 속성(Attribute) | 정책(Policy) |
| **표현력** | 낮음 | 매우 높음 | 높음 |
| **리소스 기반 제어** | 불가 | 가능 | 가능 |
| **구현 복잡도** | 낮음 | 높음 | 중간 |
| **정책-코드 분리** | 불가 | 부분 가능 | 가능 |
| **정책 변경 시** | 코드 수정 필요 | 코드 수정 필요 | 정책만 수정 |
| **학습 곡선** | 낮음 | 높음 | 중간 |
| **실무 적용 사례** | 대부분 | 일부 | AWS IAM, GCP IAM |

### RBAC를 선택하지 않은 이유
- 과거 실무에서 사용 경험이 있으며, 한계를 명확히 경험함
- 리소스 스코프 제어 불가 (예: "본인 주문만 조회")
- 도메인 확장 시 역할 폭발 문제

### ABAC를 선택하지 않은 이유
- 높은 유연성을 제공하지만, 결국 정책이 코드에 녹아들어감
- 물류 도메인에서 겪은 문제와 동일: 전략 패턴으로 개선해도 정책-코드 강결합 문제 해결 안 됨
- 속성 조합이 복잡해질수록 유지보수 어려움

## 결정

**PBAC (Policy-Based Access Control)** 방식을 채택한다.

### 핵심 선택 이유

**1. 정책과 코드의 분리**
- 정책 변경이 코드 변경을 유발하지 않음
- 정책은 데이터로 관리되어 런타임에 변경 가능
- SRP 준수: 코드의 변경 사유는 "비즈니스 로직 변경"으로 단일화

**2. 변경의 빈도 차이 인정**
- 정책은 언제든 변경될 수 있어야 함 (높은 유연성)
- 코드는 정책만큼 자주 변경되어서는 안 됨 (안정성)
- 변경의 사유가 다르므로 분리되어야 함

**3. 실무 문제 해결**
- 물류 도메인에서 겪은 "정책-코드 강결합" 문제의 해결책 탐색
- 인가 도메인에서 먼저 실험 후, 물류 검증 정책에도 적용 가능성 검토
- 토이 프로젝트 → 실무 적용의 학습 경로

## 구현 방식

### 정책 정의 (DSL)
```kotlin
policy("user", "read") {
    name = "사용자 조회 정책"
    
    allow("관리자 전체 조회") {
        condition("subject.roles", Operator.CONTAINS, "ADMIN")
    }
    
    allow("본인 정보 조회") {
        conditionRef("subject.userId", Operator.EQUALS, "resource.id")
    }
}
```

### 정책 평가
```kotlin
@RequiresPolicy(resource = "user", action = "read")
fun getUser(@PathVariable userId: Long): UserResponse
```

### 정책 동기화
```
auth-service (정책 변경)
  → Kafka (PolicyChangedEvent)
  → 각 서비스 (캐시 갱신)
```

## 트레이드오프

### 얻는 것
- 정책 변경 시 배포 불필요
- 코드 변경 사유 단순화 (SRP)
- 도메인 확장 시 유연한 대응
- 물류 검증 정책에도 적용 가능한 패턴 학습

### 포기하는 것
- 초기 구현 복잡도 증가
- 정책 엔진 및 관리 시스템 구축 필요
- 정책 DSL 학습 비용

### 리스크 완화
- 명확한 정책 DSL 문서 작성
- 정책 테스트 도구 제공
- 단계적 적용 (간단한 정책부터)
