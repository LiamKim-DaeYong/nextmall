# NextMall 로드맵

## 현재 상태

### 완성된 것

| 영역 | 완성도 |
|------|--------|
| 인증 (JWT, 로그인, 토큰 갱신) | 90% |
| 인가 (PBAC, 정책 엔진) | 85% |
| 서비스 간 통신 (내부 토큰) | 80% |
| 공통 인프라 (CQRS, Kafka, Redis) | 85% |

### 부족한 것

| 영역 | 영향 |
|------|------|
| 핵심 비즈니스 도메인 | 아키텍처 정당화 안 됨 |
| 분산 트랜잭션 시나리오 | Saga 패턴 활용처 없음 |
| API 문서화/테스트 자동화 | 개발 효율 저하 |

### 포트폴리오 관점 리스크

현재 상태로는:
- "아키텍처 설계 능력은 있네요"
- "근데 회원가입에 왜 이렇게 복잡한 구조를...?"
- "실제 비즈니스 문제 해결 경험은?"

**해결책:** 주문-결제-재고 플로우 구현 → 아키텍처가 정당화됨

---

## 로드맵

### Phase 1: Product 도메인

> Order의 의존성. 빠르게 구현.

**구현 내용**
- 상품 CRUD API
- 재고 필드 포함 (Stock과 연계)
- 카테고리 (간단히)

**학습 포인트**
- CQRS 실전 (JPA + jOOQ)
- PBAC 정책 확장 (판매자는 자기 상품만)

---

### Phase 2: Order + Stock + Saga

> 핵심. 이게 있어야 아키텍처가 정당화됨.

**구현 내용**
- 주문 생성/조회/취소
- 재고 차감/복구
- Saga 오케스트레이션 (BFF에서 조율)

**주문 생성 플로우**
```
1. 재고 확인 및 예약 (Stock)
2. 결제 처리 (Payment - Mock)
3. 재고 확정 차감
4. 주문 완료

실패 시 보상 트랜잭션:
- 재고 예약 해제
- 결제 취소
- 주문 실패 처리
```

**학습 포인트**
- Saga 패턴 (오케스트레이션)
- 분산 락 vs 낙관적 락 (재고 동시성)
- Kafka 이벤트 발행/구독
- 보상 트랜잭션

---

### Phase 3: 도구 + 고도화

> 완성도. Phase 2까지 끝나면 진행.

**API 문서화/테스트**
- Swagger (springdoc-openapi)
- Karate (시나리오 테스트 자동화)

**성능 테스트**
- k6 (동시 주문 시나리오)
- 병목 지점 분석

**안정성 강화**
- Circuit Breaker (Redis 장애 대응)
- 모니터링 (Micrometer)

---

## 도구 선택

| 도구 | 용도 | 도입 시점 |
|------|------|----------|
| **Swagger** | API 문서화, 빠른 검증 | Phase 3 |
| **Karate** | 시나리오 테스트, Git 관리 | Phase 3 |
| **k6** | 부하/성능 테스트 | Phase 3 |

---

## 학습 목표 매핑

| 학습 목표 | Phase | 구체적 실습 |
|----------|-------|------------|
| CQRS 패턴 | Phase 1 | Product 검색 (jOOQ) |
| 동시성 제어 | Phase 2 | 재고 차감 (분산 락) |
| 이벤트 드리븐 | Phase 2 | Kafka 주문 이벤트 |
| Saga 패턴 | Phase 2 | 주문-결제-재고 플로우 |
| 대규모 트래픽 | Phase 3 | k6 부하 테스트 |
| 장애 대응 | Phase 3 | Circuit Breaker |

---

## 왜 이 순서인가

1. **Product 먼저** - Order가 Product에 의존
2. **Order + Saga 핵심** - 이게 없으면 아키텍처 오버 엔지니어링으로 보임
3. **도구는 나중에** - 포트폴리오에 안 보이는 건 후순위

Phase 2까지 완료되면:
- "주문-결제-재고" 분산 트랜잭션 시나리오 있음
- PBAC, 내부 토큰, Saga 오케스트레이터가 정당화됨
- 실제 비즈니스 문제 해결 사례가 됨