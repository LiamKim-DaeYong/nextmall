# 워크플로우 아키텍처 설계

이 문서는 NextMall의 서비스 간 워크플로우 처리 방식에 대한 설계 결정과 근거를 정리한다.

---

## 1. 오케스트레이션 vs 코레오그래피

### 1.1 개념 비교

#### 오케스트레이션 (Orchestration)
```text
┌─────────────────┐
│   Orchestrator  │  ← 중앙 조율자가 전체 흐름 제어
└────────┬────────┘
         │ 동기 호출
  ┌────┬───┬────┐
  ▼    ▼   ▼    ▼
  A    B   C    D   (각 서비스는 자기 일만)
```

#### 코레오그래피 (Choreography)
```
┌───┐    ┌───┐    ┌───┐    ┌───┐
│ A │--->│ B │--->│ C │--->│ D │
└───┘    └───┘    └───┘    └───┘
  │        │        │
  ▼        ▼        ▼
    Kafka (이벤트 버스)

각 서비스가 이벤트를 발행하고 구독하며 자율적으로 반응
중앙 조율자 없음
```

### 1.2 장단점 비교

| 기준 | 오케스트레이션 | 코레오그래피 |
|------|---------------|-------------|
| **흐름 가시성** | 높음 (한 곳에서 보임) | 낮음 (흩어져 있음) |
| **결합도** | 조율자에 집중 | 분산 (느슨함) |
| **장애 전파** | 조율자 장애 = 전체 장애 | 부분 장애 격리 가능 |
| **보상 트랜잭션** | 구현 쉬움 | 구현 복잡 |
| **확장성** | 조율자 병목 가능 | 좋음 |
| **디버깅** | 쉬움 | 어려움 (이벤트 추적 필요) |

---

## 2. 하이브리드 접근

### 2.1 선택 기준

현업에서는 하이브리드 접근이 선택되는 경우가 많다.
모든 상황에 하나의 패턴이 맞지 않기 때문이다.

#### 의사결정 흐름

```
Q1: 즉각적인 응답이 필요한가?
    │
    ├─ YES → Q2로
    │
    └─ NO (나중에 완료되어도 됨) → 코레오그래피
                                   예: 이메일 발송, 캐시 갱신

Q2: 여러 서비스를 거쳐야 하는가?
    │
    ├─ YES → Q3로
    │
    └─ NO (단일 서비스) → 직접 호출

Q3: 실패 시 보상(롤백)이 필요한가?
    │
    ├─ YES → 오케스트레이션 (Saga)
    │        예: 주문+결제+재고차감
    │
    └─ NO → 상황에 따라 선택
```

### 2.2 NextMall 워크플로우 분류

| 워크플로우 | 패턴 | 이유 |
|-----------|------|------|
| **회원가입** | 오케스트레이션 | User 생성 실패 시 Auth 롤백 필요 |
| **로그인** | 직접 호출 | 단일 서비스 (Auth) |
| **주문 생성** | 오케스트레이션 | 재고 확인 → 주문 → 결제, 실패 시 보상 |
| **결제 완료 후** | 코레오그래피 | 이메일, 포인트 등 (실패해도 주문 유효) |
| **재고 변경 알림** | 코레오그래피 | 캐시 갱신 (eventual consistency OK) |
| **주문 취소** | 오케스트레이션 | 환불 + 재고 복구, 순서와 보상 중요 |

---

## 3. Outbox 패턴

Outbox는 이벤트 발행을 안정적으로 처리하기 위한 접근이다. 이 문서에서는 개념만 유지하고,
세부 규칙은 이벤트 스키마 문서로 위임한다.

- 이벤트 스키마: [event-schema.md](event-schema.md)

---

## 4. BFF와 Orchestrator의 관계

### 4.1 아키텍처 관점

#### 본질적 역할
```
BFF (Backend for Frontend)
- 프론트엔드를 위한 데이터 집계
- 여러 서비스 데이터를 조합하여 UI 최적화된 응답
- 본질적으로 "읽기" 역할

Orchestrator
- 여러 서비스에 걸친 비즈니스 워크플로우 조율
- 사가 패턴, 보상 트랜잭션
- 본질적으로 "쓰기" 역할
```

아키텍처 순수성 관점에서 이 둘은 다른 관심사이며, 같은 레벨에 위치하는 것으로 정리할 수 있다.

### 4.2 운영 관점

운영 단순성 때문에 BFF에 Orchestration을 통합하는 선택이 있는 편이다.

| 관점 | 분리 (순수) | 통합 (운영 관점) |
|------|------------|-----------|
| Gateway 라우팅 | 복잡 (읽기/쓰기 판단) | 단순 (다 BFF로) |
| 클라이언트 | 어디로 보낼지 알아야 함 | 그냥 BFF로 |
| 배포 단위 | 증가 | 감소 |
| 장애 포인트 | 2개 | 1개 |
| 팀 협업 | 책임 분산 | BFF 팀이 오너 |

### 4.3 규모별 패턴

**초기/소규모**: BFF에 Orchestration 통합
```
Gateway → BFF (읽기 + 쓰기 모두)
              │
              └→ Domain Services
```

**중간 규모**: BFF + Orchestrator 분리
```
Gateway → BFF ──────→ Orchestrator
              │              │
              └──────────────┴→ Domain Services
```

**대규모**: 클라이언트별 BFF + 도메인별 Orchestrator
```
Gateway ─┬→ Web BFF ────────┬→ Order Orchestrator
         ├→ Mobile BFF ─────┤→ Payment Orchestrator
         └→ Partner API ────┴→ Domain Services
```

### 4.4 NextMall의 선택

**현재 구조**: BFF → Orchestrator 호출 (계층 구조)

```
                              Gateway
                                 │
                                 ▼
                       ┌───────────────────┐
                       │       BFF         │  ← 클라이언트 단일 진입점
                       │                   │
                       │ • Read: direct    │ ───────────────────┐
                       │ • Write: delegate │ ──┐                │
                       └───────────────────┘   │                │
                                               ▼                ▼
                                   ┌─────────────────┐   ┌─────────────┐
                                   │   Orchestrator  │   │   Domain    │
                                   │                 │   │  Services   │
                                   │ • Sign-up saga  │   │ (Product,   │
                                   │ • Order saga    │   │  User read) │
                                   └────────┬────────┘   └─────────────┘
                                            │
                                            ▼
                                     Domain Services
                                   (User, Auth, Order
                                    Product, Checkout)
```

#### 실제 코드 구조
```kotlin
// 쓰기: BFF → Orchestrator
class SignUpFacade(
    private val orchestratorServiceClient: OrchestratorServiceClient
)

class CreateOrderFacade(
    private val orchestratorServiceClient: OrchestratorServiceClient
)

// 읽기: BFF → Domain Service 직접
class GetProductFacade(
    private val productServiceClient: ProductServiceClient
)

class GetUserFacade(
    private val userServiceClient: UserServiceClient
)
```

#### 선택 근거
- 클라이언트 단순화: 모든 요청은 BFF로
- 책임 분리: 읽기는 BFF가 직접, 쓰기 워크플로우는 Orchestrator에 위임
- 운영 관점: 단순성과 아키텍처 분리의 균형
- 학습 목적: 통합과 분리의 장단점을 직접 경험

#### 아키텍처 순수성 관점
- 순수하게는 BFF와 Orchestrator가 같은 레벨 (Gateway에서 분기)
- 하지만 운영 환경에서는 클라이언트 단순화를 위해 BFF → Orchestrator 호출을 택하는 경우가 있음
- 이 프로젝트는 운영 관점을 반영하되, 서비스 분리를 통해 패턴을 학습

---

## 5. UCP (Universal Commerce Protocol) 활용

UCP는 외부 API 계약을 참고하기 위한 기준으로 다룬다. 내부 구현은 UCP에 종속되지 않도록 분리하고,
필요할 때만 응답을 UCP 형태로 변환하는 계층을 둔다.

자세한 내용은 아래 문서에 위임한다.
- [UCP 기반 쇼핑몰 설계](ucp-design.md)
- [UCP Checkout 최소 스키마/엔드포인트](ucp-checkout-api.md)
- [UCP Order 최소 스키마/엔드포인트](ucp-order-api.md)

---

## 6. 의도적 오버엔지니어링

### 6.1 배경

이 프로젝트는 학습 목적으로, 현업에서 접하기 어려운 패턴과 구조를 직접 경험하기 위해 일부 오버엔지니어링을 포함한다.

### 6.2 원칙

```
"운영에서는 단순성이 아키텍처 순수성보다 중요하다고 보는 경우가 있다"

하지만 학습 환경에서는:
- 통합과 분리의 장단점을 직접 경험
- 각 패턴의 실제 구현 난이도 체감
- 트레이드오프를 몸으로 이해
```

### 6.3 적용 사례

| 영역 | 운영에서 자주 선택 | 이 프로젝트 | 학습 포인트 |
|------|----------|------------|------------|
| BFF/Orchestrator | 통합 | 분리 | 분리 시 운영 비용 체험 |
| CQRS | 필요시만 | JPA+jOOQ 풀 적용 | 읽기/쓰기 분리 경험 |
| 이벤트 드리븐 | 점진적 | Outbox+Kafka | 이벤트 기반 아키텍처 |
| 서비스 분리 | 최소화 | 8개 서비스 | MSA 운영 복잡도 체험 |

### 6.4 기대 학습 효과

#### 얻는 것
- 각 컴포넌트의 책임이 명확해짐
- 패턴별 실제 구현 난이도 파악
- 서비스 간 통신, 장애 전파 경험
- 분산 시스템 디버깅 경험

#### 잃는 것 (= 통합을 선택하는 이유 중 하나)
- 배포 단위 증가로 인한 운영 부담
- 서비스 간 호출로 인한 레이턴시
- 로컬 개발 환경 구성의 복잡도
- 서비스 간 계약(DTO) 관리 부담

### 6.5 운영 적용 시

학습을 통해 얻은 인사이트를 바탕으로, 운영 환경에서는 상황에 맞는 선택을 한다.

```
소규모 팀/초기 스타트업:
→ BFF 통합, 서비스 수 최소화, 모놀리식 우선

중간 규모:
→ 점진적 분리, 병목 지점만 MSA

대규모:
→ 팀 단위로 서비스 분리, 도메인별 오너십
```

---

## 7. 요약

### 핵심 원칙

```
1. 핵심 경로는 오케스트레이션 (동기, 보상 트랜잭션)
2. 부가 처리는 코레오그래피 (비동기, Outbox + Kafka)
3. 외부 API는 UCP 참고하되 100% 준수는 필요하지 않을 수 있음
4. 운영에서는 단순성을 우선하는 경우가 많고, 학습에서는 패턴 체험에 무게를 둔다
```

### NextMall 구조

```
                         Gateway
                            │
                            ▼
                   ┌────────────────┐
                   │      BFF       │  ← 단일 진입점
                   │                │
                   │ Read ──────────┼───────────────┐
                   │ Write ─┐       │               │
                   └────────┼───────┘               │
                            │                       │
                            ▼                       ▼
                   ┌────────────────┐      ┌───────────────┐
                   │  Orchestrator  │      │Domain Services│
                   │   (workflow)   │      │ (direct read) │
                   └───────┬────────┘      └───────────────┘
                           │
                           ▼
                    Domain Services
                    (User, Auth, Order,
                     Product, Checkout)
                           │
                           │ Outbox (향후)
                           ▼
                        Kafka
                           │
           ┌───────────────┼───────────────┐
           ▼               ▼               ▼
          Email          Point          Analytics
         (비동기)         (비동기)         (비동기)
```

---

## 관련 문서

- [이벤트 스키마 기준](event-schema.md)
- [UCP 기반 쇼핑몰 설계](ucp-design.md)
- [장기 개선 로드맵](../reviews/LONG_TERM_ROADMAP_2026-01-24.md)
